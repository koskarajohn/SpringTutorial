<!DOCTYPE html>
<html>
  <head>
    <title>JPA</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link rel="stylesheet" href="../css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/index.css">
    
    <script src="../js/jquery.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
  </head>

  <body>

    <nav class="navbar navbar-expand-md fixed-top" id="mainNav">

        <div class="container">
            <a class="navbar-brand" href="../index.html">SpringTutorial</a>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false">
                <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarContent">
            <ul class="navbar-nav ml-5">
                <li class="nav-item dropdown">
                          <a class="nav-link dropdown-toggle" href="#" id="navbarSpring" data-toggle="dropdown">Spring</a>
                          <div class="dropdown-menu">
                              <a class="dropdown-item" href="spring.html">What is Spring</a>
                              <a class="dropdown-item" href="spring-container.html">Spring IoC Container</a>
                              <a class="dropdown-item" href="spring-beans.html">Spring Beans</a>
                              <a class="dropdown-item" href="dependency-injection.html">Dependency Injection</a>
                              <a class="dropdown-item" href="annotations.html">Annotations</a>
                              <a class="dropdown-item" href="spring-boot.html">Spring Boot</a>
                              <a class="dropdown-item" href="spring-mvc.html">Spring Mvc</a>
                              <a class="dropdown-item" href="spring-security.html">Spring Security</a>
                              <a class="dropdown-item" href="html/rest-api.html">Rest API</a>
                            </div>
                      </li>
                      <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarJpa" data-toggle="dropdown">JPA</a>
                            <div class="dropdown-menu">
                              <a class="dropdown-item" href="jpa.html">JPA</a>
                              <a class="dropdown-item" href="spring-data-jpa.html">Spring Data Jpa</a>
                            </div>
                      </li>
                      <li class="nav-item dropdown">
                          <a class="nav-link dropdown-toggle" href="#" id="navbarSetup" data-toggle="dropdown">Setup εφαρμογης</a>
                          <div class="dropdown-menu">
                              <a class="dropdown-item" href="spring-tool-suite.html">Spring Tool Suite</a>
                              <a class="dropdown-item" href="heroku.html">Heroku</a>
                              <a class="dropdown-item" href="postgresql.html">Postgres</a>
                            </div>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarCreateApp" data-toggle="dropdown">Δημιουργία εφαρμογης</a>
                        <div class="dropdown-menu">
                            <a class="dropdown-item" href="app-architecture.html">Αρχιτεκτονική εφαρμογής</a>
                            <a class="dropdown-item" href="angular.html">Angular</a>
                          </div>
                      </li>
            </ul>
        </div>
      </div>
   
    </nav>

    <div class="container">

        <h1 class="text-center">JPA</h1>

        <section class="intro">

            <p>Το <span class="bold">Java Persistance API (JPA)</span> είναι ένα Java <span class="bold">specification</span>, μέρος της Java EE, 
                για την <span class="bold">ανάκτηση, αποθήκευση και διαχείριση δεδομένων</span>, μεταξύ αντικειμένων της Java και της σχεσιακής βάσης δεδομένων. Θεωρείται η πιο standard προσέγγιση για 
                <span class="bold">Object to Relational Mapping (ORM)</span> στη βιομηχανία της Java.
            </p>

            <p>To JPA είναι ένα <span class="bold">σύνολο</span> από <span class="bold">διεπαφές</span>, οι οποίες απαιτούν μια υλοποίηση. Δημοφιλείς υλοποιήσεις είναι το Hibernate, EclipseLink και 
                Apache OpenJPA. Η υλοποίηση του JPA συνήθως λέγεται persistence provider.
            </p>

            <p>Επίσης, επιτρέπει στους developers, να <span class="bold">δουλεύουν απευθείας με objects (POJOs)</span>, <span class="bold">αντί με εντολές SQL</span>. Η αντιστοίχιση των κλάσεων της Java, με 
                τους πίνακες της βάσης δεδομένων πραγματοποιείται με annotations ή XML. Παρακάτω, δίνεται ένα παράδειγμα αποθήκευσης ενός entity στη βάση δεδομένων:
            </p>

        </section>

        <section class="entities">

            <h5>Entities</h5>

            <p>Ένα entity είναι ένα <span class="bold">ελαφρύ</span>, <span class="bold">persistance domain object</span>. Αντιπροσωπεύει έναν <span class="bold">πίνακα</span> στην <span class="bold">βάση δεδομένων</span> 
                και <span class="bold">κάθε στιγμιότυπο</span> του entity, <span class="bold">αντιστοιχεί σε μια γραμμή</span> εκείνου του πίνακα. 
                Μια entity κλάση πρέπει, να ικανοποιεί τις ακόλουθες απαιτήσεις:
            </p>

            <ul>
                <li>Η κλάση πρέπει, να έχει το annotation <span class="code">@Entity</span>.</li>
                <li>Η κλάση πρέπει <span class="bold">τουλάχιστον</span> έναν <span class="code">public</span> ή <span class="code">protected</span>, <span class="bold">κενό κατασκευαστή</span>. </li>
                <li>Η κλάση δεν πρέπει, να δηλωθεί ως <span class="code">final</span>. Καμία μέθοδος ή persistent μεταβλητή στιγμιότυπου δεν πρέπει, να δηλωθεί ως <span class="code">final</span>.</li>
            </ul>

            <p>Όλα τα πεδία αποθηκεύονται στη βάση δεδομένων, εκτός αν κάποιο έχει το annotation <span class="code">@Transient</span>. Παρακάτω δίνεται ένα παράδειγμα 
            ενος Entity. Αντιστοιχίζεται η κλάση Category, με τον πίνακα categories της βάσης δεδομένων.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Entity</span>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Table(</span>name = <span class="string">"categories"</span>)
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public class</span> Category{

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Id</span>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(</span>name = <span class="string">"id"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private int</span> id;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(name = </span><span class="string">"name"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@NotNull(</span>message = <span class="string">"Please provide category name"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Size(</span>min = 3, max = 200, message = <span class="string">"Name must be between 3 and 200 characters"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private String</span> name;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Transient</span>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private String</span> thisWillNotBeSavedInTheDatabaseTable;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> Category() {}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Getters - Setters ...</span>

                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>
        </section>

        <section class="validation">
            <h5>Bean validation</h5>

            <p>Το Java API για τα <span class="bold">JavaBeans Validation (Bean Validation)</span> παρέχει έναν μηχανισμό, για να κάνουμε <span class="bold">validate τα δεδομένα</span> της εφαρμογής.</p>

            <p>Παρέχει <span class="bold">περιορισμούς</span> Bean Validation, τα οποία <span class="bold">εφαρμοζόνται στα πεδία</span> των persistent κλάσεων.</p>

            <p>Στο προηγούμενο παράδειγμα, το annotation <span class="code">@NotNull</span> του πεδίου name, δηλώνει ότι το πεδίο αυτό είναι υποχρεωτικό. Εάν δημιουργηθεί ένα 
                στιγμιότυπο Category, στο οποίο δεν έχει αρχικοποιηθεί το πεδίο name, τότε το Bean Validation θα προκαλέσει ένα <span class="bold">validation error</span>. Αντιστοίχα,
                το annotation <span class="code">@Size</span> δηλώνει ότι το πεδίο name, πρέπει να έχει μήκος 3 εώς 200 χαρακτήρων. 
            </p>
        </section>

        <section class="primary-keys">
            <h5>Πρωτεύοντα κλειδιά στα Entities</h5>

            <p>Κάθε entity έχει <span class="bold">ένα μοναδικό αναγνωριστικό</span> αντικειμένου, δηλαδή ένα <span class="bold">πρωτεύον κλειδί</span>. 
                Αυτό μπορεί, να είναι <span class="bold">απλό</span> ή <span class="bold">σύνθετο</span>.</p>

            <p>Για να δηλώσουμε ένα <span class="bold">απλό</span> πρωτεύον κλειδί, χρησιμοποιούμε το <span class="bold">annotation</span> <span class="code">@Id</span>.</p>

            <p><span class="bold">Σύνθετο</span> πρωτεύον κλειδί χρησιμοποιούμε, όταν το <span class="bold">κλειδί αποτελείται από περισσότερα από ενα πεδία</span>. Τότε το κλειδί πρέπει, να οριστεί σε μια κλάση
                πρωτεύοντος κλειδιού. Για να δηλώσουμε, ένα σύνθετο πρωτεύον κλειδί, χρησιμοποιούμε το <span class="bold">annotation</span> <span class="code">@EmbeddedId</span>.
            </p>

            <p>Παράδειγμα απλού πρωτεύοντος κλειδιού.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Entity</span>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Table(</span>name = <span class="string">"categories"</span>)
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public class</span> Category{

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Id</span>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(</span>name = <span class="string">"id"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private int</span> id;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(name = </span><span class="string">"name"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@NotNull(</span>message = <span class="string">"Please provide category name"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Size(</span>min = 3, max = 200, message = <span class="string">"Name must be between 3 and 200 characters"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private String</span> name;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> Category() {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Getters - Setters ...</span>
		
	                &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}

                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>

            <p>Παράδειγμα σύνθετου πρωτεύοντος κλειδιού.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Embeddable</span> 
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public class</span> OrderProductPrimaryKey implements Serializable{

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private int</span> orderId;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private int</span> productId;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> OrderProductPrimaryKey() {}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> OrderProductPrimaryKey(<span class="keyword">int</span> orderId, <span class="keyword">int</span> productId) {
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   <span class="this">this</span>.orderId = orderId;
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   <span class="this">this</span>.productId = productId;
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Override</span> 
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public boolean</span> equals(Object o) {
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <span class="keyword">if</span> (<span class="this">this</span> == o) <span class="keyword">return true</span> ;
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> OrderProductPrimaryKey))<span class="keyword"> return false</span> ;
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; OrderProductPrimaryKey that = (OrderProductPrimaryKey) o;    
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <span class="keyword">return</span>  Objects.equals(getOrderId(), that.getOrderId()) && Objects.equals(getProductId(), that.getProductId());
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Override</span> 
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public int</span> hashCode() {
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <span class="keyword">return</span>  Objects.hash(getOrderId(), getProductId());
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Getters - Setters ...</span>

                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Entity</span> 
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Table(</span>name = <span class="string">"order_products"</span>)
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public class</span> OrderProduct  {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@EmbeddedId</span> 
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private</span> OrderProductPrimaryKey id;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@OneToOne</span> (fetch = FetchType.LAZY)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@MapsId(</span><span class="string">"orderId"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private</span> Order order;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@OneToOne</span> (fetch = FetchType.LAZY)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@MapsId(</span><span class="string">"productId"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private</span> Product product;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@NotNull</span> (message = "Please provide quantity"))
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(</span>name = <span class="string">"quantity"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private</span> int quantity;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> OrderProduct() {}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Getters - Setters ...</span>

                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>
        </section>

        <section class="multiplicity ">

            <h5>Πολλαπλότητα στις σχέσεις των entities</h5>

            <table class="multiplicity-annotations">
                <tr>
                    <th>Πολλαπλότητα</th>
                    <th>Περιγραφή</th>
                </tr>
                <tr>
                    <td><span class="bold">1-1</span></td>
                    <td><span class="bold">Κάθε στιγμιότυπο</span> του entity, συσχετίζεται με <span class="bold">ένα μόνο στιγμιότυπο</span> ενός άλλου entity. Χρησιμοποιούμε το annotation <span class="bold">@OneToOne</span> στο αντίστιοιχο πεδίο.</td>
                </tr>
                <tr>
                    <td><span class="bold">1-Ν</span></td>
                    <td><span class="bold">Κάθε στιγμιότυπο</span> του entity, συσχετίζεται με <span class="bold">πολλά στιγμιότυπα</span> ενός άλλου entity. Χρησιμοποιούμε το annotation <span class="bold">@OneToMany</span> στο αντίστιοιχο πεδίο.</td>
                </tr>
                <tr>
                    <td><span class="bold">Ν-1</span></td>
                    <td><span class="bold">Πολλά στιγμιότυπα</span> του entity, συσχετίζονται με <span class="bold">ένα μόνο στιγμιότυπο</span> ενός άλλου entity. Χρησιμοποιούμε το annotation <span class="bold">@ManyToOne</span> στο αντίστιοιχο πεδίο.</td>
                </tr>
                <tr>
                    <td><span class="bold">Ν-Ν</span></td>
                    <td><span class="bold">Πολλά στιγμιότυπα</span> του entity, συσχετίζονται με <span class="bold">πολλά στιγμιότυπα</span> ενός άλλου entity. Χρησιμοποιούμε το annotation <span class="bold">@ManyToMany</span> στο αντίστιοιχο πεδίο.</td>
                </tr>
            </table>

            <p class="mt-5">Παρακάτω, δίνεται ένα παράδειγμα Ν-1. Στην βάση δεδομένων υπάρχουν δύο πίνακες products και categories, οι οποίοι αντιστιχίζονται με 
                τα entities Product και Category. Ο πίνακας products έχει ένα ξένο κλειδί category_id, το οποίο αναφέρεται στο πρωτεύον κλειδί του πίνακα
                 categories. Το entity Product έχει ένα πεδίο Category, το οποίο έχει annotation <span class="code">@ManyToOne</span>. Αυτό το annotation σημαίνει ότι πολλά προιόντα
                 μπορούν, να ανήκουν σε μία μόνο κατηγορία.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Entity</span> 
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@Table(</span>name = <span class="string">"products"</span>)
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public class</span> Product  {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Id</span>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@Column(</span>name = <span class="string">"id"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private int</span> id;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@ManyToOne</span> (optional = false)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@JoinColumn(</span>name = <span class="string">"category_id"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="annotation">@NotNull</span> 
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">private</span> Category category;

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Rest of the fields ...</span>

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">public</span> Product() {}

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="comments">//Getters - Setters ...</span>

                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>
        </section>

        <section class="entity-managers">
            <h5>Entity Manager</h5>

            <p>Τα entities <span class="bold">διαχειρίζονται από τον entity manager</span>, ο οποίος αντιπροσωπεύεται από την <span class="bold">διεπαφή</span> <span class="code">javax.persistence.EntityManager</span>.
                Κάθε στιγμιότυπο EntityManager είναι συσχετισμένο με ένα persistence context. <span class="bold">Persistence context</span> είναι<span class="bold">ένα σύνολο από 
                    διαχειριζόμενα στιγμιότυπα από entities</span> , τα οποία υπάρχουν σε μια συγκεκριμένη <span class="bold">αποθήκη δεδομένων</span>. Ορίζει την εμβέλεια, μέσα στην οποία δημιουργούνται,
                ανακτούνται και διαγράφονται τα στιγμιότυπα των entities. Η διεπαφή EntityManager παρέχει <span class="bold">μεθόδους για την αλληλεπίδραση</span> με το Persistence Context.
            </p>

            <p class="font-weight-bold">Container-Managed Entity Managers</p>

            <p >Στην περίπτωση του Container-Managed Entity Manager, ο EntityManager δημιουργείται και διαχειρίζεται από το container. Για να πάρουμε ένα
                στιγμιότυπο του EntityManager, τον κάνουμε inject.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@PersistenceContext</span> 
                    &emsp;&emsp;&emsp;&emsp;EntityManager em;
                </code>
            </pre>

            <p class="font-weight-bold">Application-Managed Entity Managers</p>

            <p>Στην περίπτωση του Application-Managed Entity Manager, πρέπει εμείς, να δημιουργήσουμε και να διαχειρίστουμε τον EntityManager. Για να πάρουμε ένα
                στιγμιότυπο του EntityManager, πρέπει πρώτα να κάνουμε inject ένα EntityManagerFactory.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="annotation">@PersistenceUnit</span> 
                    &emsp;&emsp;&emsp;&emsp;EntityManagerFactory emf;
                    &emsp;&emsp;&emsp;&emsp;EntityManager em = emf.createEntityManager();
                </code>
            </pre>
        </section>

        <section class="jpql">

            <h5>JPQL</h5>

            <p class="mt-4">Η <span class="bold">Java Persistence query language</span> ορίζεται στο <span class="bold">JPA specification</span> και μας επιτρέπει να <span class="bold">ορίσουμε ερωτήματα πάνω σε entities</span>, τα οποία είναι αποθηκευμένα στη
                βάση δεδομένων.
            </p>

            <p class="font-weight-bold">Σύνταξη</p>

            <p>Η <span class="bold">σύνταξη</span> της γλώσσας είναι <span class="bold">παρόμοια με</span>  αυτή της <span class="bold">SQL</span>. Η SQL δουλεύει άμεσα με τη <span class="bold">βάση δεδομένων</span> και τις εγγραφές, ενώ η JPQL 
                δουλεύει με τις <span class="bold">κλάσεις Entities</span> και τα στιγμιότυπα τους. Παρακάτω δίνεται η σύνταξη ενός <span class="bold">SELECT</span> ερωτήματος, για να ανακτήσουμε ένα entity.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...
                    &emsp;&emsp;&emsp;&emsp;[<span class="keyword">WHERE</span> ...]
                    &emsp;&emsp;&emsp;&emsp;[<span class="keyword">GROUP BY</span> ... [<span class="keyword">HAVING </span> ...]]
                    &emsp;&emsp;&emsp;&emsp;[<span class="keyword">ORDER BY</span> ...]
                </code>
            </pre>

            <p>Η σύνταξη των ερωτημάτων <span class="bold">DELETE</span> και <span class="bold">UPDATE</span> ερωτήματος δίνεται παρακάτω.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">DELETE FROM</span> ... [<span class="keyword">WHERE  </span> ...]
                    
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">UPDATE</span> ... <span class="keyword">SET</span> ... [<span class="keyword">WHERE  </span> ...]
                </code>
            </pre>

            <p>Μπορούμε, να πραγματοποιήσουμε ερωτήματα χρησιμοποιώντας τη μέθοδο <span class="code">EntityManager.createQuery</span> του EntityManager και την <span class="code">Query.executeUpdate</span>.
                Παρακάτω δίνονται παραδείγματα <span class="bold">SELECT</span>, <span class="bold">UPDATE</span> και <span class="bold">DELETE</span> ερωτημάτων για την κλάση Entity <span class="bold">Category</span>. 
            </p>

            <pre>
                <code>

                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public Category</span>  findCategoryWithName(String name)  {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="keyword">return</span> em.createQuery(
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="string">"SELECT c FROM Category c WHERE c.name = :name"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.setParameter(<span class="string">"name"</span>, <span class="string">"Vitamins"</span>)
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.getResultList();
                    &emsp;&emsp;&emsp;&emsp;} 
                </code>
            </pre>

            <pre>
                <code>

                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public void</span>  updateCategory(String name)  {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Query query = em.createQuery(<span class="string">"UPDATE Category c SET c.name = :newName WHERE c.name = :oldName"</span>);
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;query.setParameter(<span class="string">"newName"</span>, <span class="string">"Basket"</span>);
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;query.setParameter(<span class="string">"oldName"</span>, <span class="string">"Football"</span>);
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int rowsUpdated = query.executeUpdate();
                    &emsp;&emsp;&emsp;&emsp;} 
                    
                </code>
            </pre>

            <pre>
                <code>

                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">public void</span>  deleteCategory(String name)  {

                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Query query = em.createQuery(<span class="string">"DELETE FROM Category c WHERE c.name = :name"</span>);
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;query.setParameter(<span class="string">"name"</span>, <span class="string">"Basket"</span>);
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int rowsDeleted = query.executeUpdate();
                    &emsp;&emsp;&emsp;&emsp;} 
                    
                </code>
            </pre>
        </section>

        <section class="criteria-api">

            <h5>Criteria API</h5>

            <p class="mt-4">Το JPA <span class="bold">Criteria API</span> παρέχει έναν εναλλακτικό τρόπο, για να εκτελούμε <span class="bold">δυναμικά JPA ερωτήματα</span>, των οποίων η δομή είναι γνωστή, 
                μόνα κατά την διάρκεια εκτέλεσης της εφαρμογής. Για παράδειγμα, μπορούμε να πραγματοποιήσουμε ένα δυναμικό ερώτημα, βασιζόμενοι στα φίλτρα αναζήτησης,
                τα οποία έχει επιλέξει ένας χρήστης.</p>

            <p>Το <span class="code">CriteriaBuilder</span> είναι η κύρια διεπαφή του Criteria API. Μπορούμε, να δημιουργήσουμε ένα στιγμιότυπο του <span class="code">CriteriaBuilder</span> από τον <span class="bold">EntityManager</span>,
                χρησιμοποιώντας τη μέθοδο <span class="code">getCriteriaBuilder</span>. Το <span class="code">CriteriaBuilder</span> χρησιμοποιείται, για να δημιουργήσουμε <span class="code">CriteriaQuery</span> αντικείμενα. Τα
                αντικείμενα <span class="code">CriteriaQuery</span> ορίζουν ένα συγκεκριμένο ερώτημα, με το οποίο θα διασχίσουμε ένα ή περισσότερα entities.
            </p>

            <p>Παρακάτω δίνεται ένα απλό ερώτημα σε JPQL </p>    

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;<span class="keyword">SELECT</span> c <span class="keyword">FROM</span> Category c 
                </code>
            </pre>

            <p>Μπορούμε, να πραγματοποιήσουμε το ίδιο ερώτημα με το JPA Criteria API</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaBuilder cb = em.getCriteriaBuilder();

                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Category&#62; q = cb.createQuery(Category.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Category&#62; c = q.from(Category.class);
                    &emsp;&emsp;&emsp;&emsp;q.select(c);
                    &emsp;&emsp;&emsp;&emsp;List&#60;Category&#62; categories = entityManager.createQuery(q).getResultList();
                </code>
            </pre>

            <p class="font-weight-bold mt-4">Query Root</p>

            <p>Για κάθε <span class="code">CriteriaQuery</span> αντικείμενο, το entity ρίζα του ερωτήματος, από το οποίο ξεκινάμε, να διασχίζουμε, λέγεται <span class="bold">query root</span>.
                Είναι αντίστοιχο με το <span class="bold">FROM</span> ενός JPQL ερωτήματος.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Category&#62; q = cb.createQuery(Category.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Category&#62; c = q.from(Category.class);
                </code>
            </pre>

            <p>Μπορούμε, να δημιουργήσουμε συνθήκες χρησιμοποιώντας τη μέθοδο <span class="code">CriteriaQuery.where</span>, η οποία περιορίζει τα αποτελέσματα ενός ερωτήματος
                στο αντικείμενο <span class="code">CriteriaQuery</span>. Η μέθοδος <span class="code">where</span> αντιστοιχεί με το <span class="bold">WHERE</span> ενός JPQL ερωτήματος.
            </p>

            <p>Η μέθοδος <span class="code">where</span> αποτιμά στιγμιότυπα της διεπαφής <span class="code">Expression</span>, ώστε να περιορίσει τα αποτελέσματα, ανάλογα με τις συνθήκες των expressions. Το
                ακόλουθο ερώτημα χρησιμοποιεί τη μέθοδο <span class="code">Expression.isNull</span>, για να βρει όλα τα προιόντα, στα οποία το πεδίο description είναι <span class="code">NULL</span>.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Product&#62; cq = cb.createQuery(Product.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Product&#62; product = cq.from(Product.class);
                    &emsp;&emsp;&emsp;&emsp;cq.where(product.get(<span class="string">"description</span>).isNull());
                </code>
            </pre>   

            <p>Η διεπαφή <span class="code">CriteriaBuilder</span> παρέχει επιπλέον μεθόδους, για τη δημιουργία expressions.</p>

            <table class="expressions">
                    <tr>
                        <th>Keyword</th>
                        <th>Sample</th>
                    </tr>

                    <tr>
                        <td><span class="bold">equal</span></td>
                        <td>Ελέγχει, εάν δύο expressions είναι ίσα</td>
                    </tr>

                    <tr>
                        <td><span class="bold">notEqual</span></td>
                        <td>Ελέγχει, εάν δύο expressions δεν είναι ίσα</td>
                    </tr>

                    <tr>
                        <td><span class="bold">gt</span></td>
                        <td>Ελέγχει, εάν το πρώτο αριθμητικό expression είναι μεγαλύτερο του δεύτερου αριθμητικού expression</td>
                    </tr>

                    <tr>
                        <td><span class="bold">ge</span></td>
                        <td>Ελέγχει, εάν το πρώτο αριθμητικό expression είναι μεγαλύτερο ή ίσο, σε σχέση με το δεύτερο αριθμητικού expression</td>
                    </tr>

                    <tr>
                        <td><span class="bold">lt</span></td>
                        <td>Ελέγχει, εάν το πρώτο αριθμητικό expression είναι μικρότερο του δεύτερου αριθμητικού expression</td>
                    </tr>

                    <tr>
                        <td><span class="bold">le</span></td>
                        <td>Ελέγχει, εάν το πρώτο αριθμητικό expression είναι μικρότερο ή ίσο, σε σχέση με το δεύτερο αριθμητικού expression</td>
                    </tr>

                    <tr>
                        <td><span class="bold">between</span></td>
                        <td>Ελέγχει, εάν η τιμή του πρώτου expression, βρίσκεται ανάμεσα στη τιμή ένος δεύτερου και τρίτου expression</td>
                    </tr>

                    <tr>
                        <td><span class="bold">like</span></td>
                        <td>Ελέγχει, εάν το expression ικανοποιεί ένα συγκεκριμένο pattern</td>
                    </tr>

            </table>

            <p class="mt-5">Το παρακάτω ερώτημα επιστρέφει το προιον με όνομα Iphone-4.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Product&#62; cq = cb.createQuery(Product.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Product&#62; product = cq.from(Product.class);
                    &emsp;&emsp;&emsp;&emsp;cq.where(cb.equal(product.get( <span class="string">"name</span>), <span class="string">"Iphone-4"</span>));
                </code>
            </pre>

            <p>Επίσης, η διεπαφή <span class="code">CriteriaBuilder</span> παρέχει τις μεθόδους <span class="code">and</span>, <span class="code">or</span> και <span class="code">not</span>, 
                οι οποίες αντιστιχούν στους τελεστές <span class="bold">AND</span>, <span class="bold">OR</span> και <span class="bold">NOT</span>.</p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Product&#62; cq = cb.createQuery(Product.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Product&#62; product = cq.from(Product.class);
                    &emsp;&emsp;&emsp;&emsp;cq.where(cb.equal(product.get(<span class="string">"id"</span>), 3).or(cb.equal(product.get(<span class="string">"name"</span>), <span class="string">"Iphone-4"</span>)));
                </code>
            </pre>

            <p>Τέλος, μπορούμε να κατατάξουμε τα αποτελέσματα, χρησιμοποιώντας <span class="code">CriteriaQuery.orderBy</span> και δίνοντας ως παράμετρο ένα αντικείμενο <span class="code">Order</span>.
                Παρακάτω δίνεται ένα παράδειγμα.
            </p>

            <pre>
                <code>
                    &emsp;&emsp;&emsp;&emsp;CriteriaQuery&#60;Product&#62; cq = cb.createQuery(Product.class);
                    &emsp;&emsp;&emsp;&emsp;Root&#60;Product&#62; product = cq.from(Product.class);
                    &emsp;&emsp;&emsp;&emsp;cq.select(product);
                    &emsp;&emsp;&emsp;&emsp;cq.orderBy(cb.asc(product.get(<span class="string">"price</span>)));
                </code>
            </pre>

        </section>

        <section class="references">

            <h5>Πηγές</h5>

            <ul>
                <li><a href="https://javaee.github.io/tutorial/persistence-intro002.html">Java EE 8 - Entities</a></li>
                <li><a href="https://javaee.github.io/tutorial/persistence-intro004.html#BNBQY">Java EE 8 - Managing Entities</a></li>
                <li><a href="https://en.wikibooks.org/wiki/Java_Persistence/What_is_JPA%3F">Wikibooks : Java Persistence/What is JPA?</a></li>
                <li><a href="http://www.vogella.com/tutorials/JavaPersistenceAPI/article.html">Voggela : Java persistence API - Tutorial</a></li>
                <li><a href="https://www.tutorialspoint.com/jpa/jpa_jpql.htm">tutorialspoint : JPA - JPQL</a></li>
                <li><a href="https://javaee.github.io/tutorial/persistence-querylanguage.html">Java EE 8 - 42 The Java Persistence Query Language</a></li>
                <li><a href="https://en.wikibooks.org/wiki/Java_Persistence/Criteria">Wikibooks : Java Persistence/Criteria</a></li>
                <li><a href="https://www.objectdb.com/java/jpa/query/criteria">ObjectDB - JPA Criteria API Queries</a></li>
                <li><a href="https://javaee.github.io/tutorial/persistence-criteria.html">Java EE 8 - 43 Using the Criteria API to Create Queries</a></li>
            </ul>
        </section>
        
    </div>

  </body>
</html>
